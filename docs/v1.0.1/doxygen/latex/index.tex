\label{index_md__Users_fboemer_repos_DBIO_intel_hexl_README}%
\Hypertarget{index_md__Users_fboemer_repos_DBIO_intel_hexl_README}%
Intel\+:registered\+: HEXL is an open-\/source library which provides efficient implementations of integer arithmetic on Galois fields. Such arithmetic is prevalent in cryptography, particularly in homomorphic encryption (HE) schemes. Intel HEXL targets integer arithmetic with word-\/sized primes, typically 40-\/60 bits. Intel HEXL provides an API for 64-\/bit unsigned integers and targets Intel CPUs.\hypertarget{index_autotoc_md1}{}\doxysection{Contents}\label{index_autotoc_md1}

\begin{DoxyItemize}
\item \href{\#intel-homomorphic-encryption-acceleration-library-hexl}{\texttt{ Intel Homomorphic Encryption Acceleration Library (HEXL)}}
\begin{DoxyItemize}
\item \href{\#contents}{\texttt{ Contents}}
\item \href{\#introduction}{\texttt{ Introduction}}
\item \href{\#building-intel-hexl}{\texttt{ Building Intel HEXL}}
\begin{DoxyItemize}
\item \href{\#dependencies}{\texttt{ Dependencies}}
\item \href{\#compile-time-options}{\texttt{ Compile-\/time options}}
\item \href{\#compiling-intel-hexl}{\texttt{ Compiling Intel HEXL}}
\end{DoxyItemize}
\item \href{\#testing-intel-hexl}{\texttt{ Testing Intel HEXL}}
\item \href{\#benchmarking-intel-hexl}{\texttt{ Benchmarking Intel HEXL}}
\item \href{\#using-intel-hexl}{\texttt{ Using Intel HEXL}}
\item \href{\#debugging}{\texttt{ Debugging}}
\item \href{\#threading}{\texttt{ Threading}}
\end{DoxyItemize}
\item \href{\#documentation}{\texttt{ Documentation}}
\begin{DoxyItemize}
\item \href{\#doxygen}{\texttt{ Doxygen}}
\item \href{\#sphinx}{\texttt{ Sphinx}}
\end{DoxyItemize}
\item \href{\#contributing}{\texttt{ Contributing}}
\begin{DoxyItemize}
\item \href{\#repository-layout}{\texttt{ Repository layout}}
\item \href{\#intel-hexl-publication}{\texttt{ Intel HEXL Publication}}
\item \href{\#citing-intel-hexl}{\texttt{ Citing Intel HEXL}}
\begin{DoxyItemize}
\item \href{\#version-10}{\texttt{ Version 1.\+0}}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_autotoc_md2}{}\doxysection{Introduction}\label{index_autotoc_md2}
Many cryptographic applications, particularly homomorphic encryption (HE), rely on integer polynomial arithmetic in a finite field. HE, which enables computation on encrypted data, typically uses polynomials with degree {\ttfamily N} a power of two roughly in the range {\ttfamily N=\mbox{[}2$^\wedge$\{10\}, 2$^\wedge$\{17\}\mbox{]}}. The coefficients of these polynomials are in a finite field with a word-\/sized primes, {\ttfamily p}, up to {\ttfamily p}$\sim$62 bits. More precisely, the polynomials live in the ring {\ttfamily Z\+\_\+p\mbox{[}X\mbox{]}/(X$^\wedge$N + 1)}. That is, when adding or multiplying two polynomials, each coefficient of the result is reduced by the prime modulus {\ttfamily p}. When multiplying two polynomials, the resulting polynomials of degree {\ttfamily 2N} is additionally reduced by taking the remainder when dividing by {\ttfamily X$^\wedge$\+N+1}.

The primary bottleneck in many HE applications is polynomial-\/polynomial multiplication in {\ttfamily Z\+\_\+p\mbox{[}X\mbox{]}/(X$^\wedge$N + 1)}. For efficient implementation, Intel HEXL implements the negacyclic number-\/theoretic transform (NTT). To multiply two polynomials, {\ttfamily p\+\_\+1(x), p\+\_\+2(x)} using the NTT, we perform the Fwd\+NTT on the two input polynomials, then perform an element-\/wise modular multiplication, and perform the Inv\+NTT on the result.

Intel HEXL implements the following functions\+:
\begin{DoxyItemize}
\item The forward and inverse negacyclic number-\/theoretic transform (NTT)
\item Element-\/wise vector-\/vector modular multiplication
\item Element-\/wise vector-\/scalar modular multiplication with optional addition
\item Element-\/wise modular multiplication
\end{DoxyItemize}

For each function, the library implements one or several Intel(\+R) AVX-\/512 implementations, as well as a less performant, more readable native C++ implementation. Intel HEXL will automatically choose the best implementation for the given CPU Intel(\+R) AVX-\/512 feature set. In particular, when the modulus {\ttfamily p} is less than {\ttfamily 2$^\wedge$\{50\}}, the AVX512\+IFMA instruction set available on Intel Ice\+Lake server and Ice\+Lake client will provide a more efficient implementation.

For additional functionality, see the public headers, located in {\ttfamily include/hexl} \hypertarget{index_autotoc_md3}{}\doxysection{Building Intel HEXL}\label{index_autotoc_md3}
\hypertarget{index_autotoc_md4}{}\doxysubsection{Dependencies}\label{index_autotoc_md4}
We have tested Intel HEXL on the following operating systems\+:
\begin{DoxyItemize}
\item Ubuntu 18.\+04
\item mac\+OS 10.\+15
\item Microsoft Windows 10
\end{DoxyItemize}

Intel HEXL requires the following dependencies\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Dependency   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Version    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Dependency   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Version    }\\\cline{1-2}
\endhead
CMake   &$>$= 3.\+5.\+1    \\\cline{1-2}
Compiler   &gcc $>$= 7.\+0, clang++ $>$= 5.\+0, MSVC $>$= 2019   \\\cline{1-2}
\end{longtabu}


For best performance, we recommend using a processor with AVX512-\/\+IFMA52 support, and a recent compiler (gcc $>$= 8.\+0, clang++ $>$= 6.\+0). To determine if your process supports AVX512-\/\+IFMA52, simply look for {\ttfamily HEXL\+\_\+\+HAS\+\_\+\+AVX512\+IFMA} during the configure step (see \href{\#compiling-hexl}{\texttt{ Compiling Intel HEXL}}).\hypertarget{index_autotoc_md5}{}\doxysubsection{Compile-\/time options}\label{index_autotoc_md5}
In addition to the standard CMake build options, Intel HEXL supports several compile-\/time flags to configure the build. For convenience, they are listed below\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ CMake option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Values   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ CMake option   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Values   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-3}
\endhead
HEXL\+\_\+\+BENCHMARK   &ON / OFF (default ON)   &Set to ON to enable benchmark suite via Google benchmark    \\\cline{1-3}
HEXL\+\_\+\+COVERAGE   &ON / OFF (default OFF)   &Set to ON to enable coverage report of unit-\/tests    \\\cline{1-3}
HEXL\+\_\+\+DEBUG   &ON / OFF (default OFF)   &Set to ON to enable debugging at large runtime penalty    \\\cline{1-3}
HEXL\+\_\+\+DOCS   &ON / OFF (default OFF)   &Set to ON to enable building of documentation    \\\cline{1-3}
HEXL\+\_\+\+ENABLE\+\_\+\+ADDRESS\+\_\+\+SANITIZER   &ON / OFF (default OFF)   &Set to ON to enable building with address sanitizer (ASan)    \\\cline{1-3}
HEXL\+\_\+\+ENABLE\+\_\+\+THREAD\+\_\+\+SANITIZER   &ON / OFF (default OFF)   &Set to ON to enable building with thread sanitizer (TSan)    \\\cline{1-3}
HEXL\+\_\+\+ENABLE\+\_\+\+UB\+\_\+\+SANITIZER   &ON / OFF (default OFF)   &Set to ON to enable building with undefined behavior sanitizer (UBSan)    \\\cline{1-3}
HEXL\+\_\+\+EXPORT   &ON / OFF (default OFF)   &Set to ON to enable export of Intel HEXL for use in 3rd-\/party project    \\\cline{1-3}
HEXL\+\_\+\+SHARED\+\_\+\+LIB   &ON / OFF (default OFF)   &Set to ON to enable building shared library    \\\cline{1-3}
HEXL\+\_\+\+TESTING   &ON / OFF (default ON)   &Set to ON to enable building of unit-\/tests    \\\cline{1-3}
HEXL\+\_\+\+TREAT\+\_\+\+WARNING\+\_\+\+AS\+\_\+\+ERROR   &ON / OFF (default OFF)   &Set to ON to treat all warnings as error   \\\cline{1-3}
\end{longtabu}
\hypertarget{index_autotoc_md6}{}\doxysubsection{Compiling Intel HEXL}\label{index_autotoc_md6}
The instructions to build Intel HEXL are common between Linux, Mac\+OS, and Windows.

To compile Intel HEXL from source code, first clone the repository into your current directory. Then, to configure the build, call 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/S . -\/B build}

\end{DoxyCode}
 adding the desired compile-\/time options with a {\ttfamily -\/D} flag. For instance, to build Intel HEXL with debugging capabilities, call 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/S . -\/B build -\/DHEXL\_DEBUG=ON}

\end{DoxyCode}


Then, to build Intel HEXL, call 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build}

\end{DoxyCode}
 This will build the Intel HEXL library in the {\ttfamily build/hexl/lib/} directory.

To install Intel HEXL to the installation directory, run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/install build}

\end{DoxyCode}
 To use a non-\/standard installation directory, configure the build with 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/S . -\/B build -\/DCMAKE\_INSTALL\_PREFIX=/path/to/install}

\end{DoxyCode}
\hypertarget{index_autotoc_md7}{}\doxysection{Testing Intel HEXL}\label{index_autotoc_md7}
To run a set of unit tests via Googletest, configure and build Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+TESTING=ON} (see \href{\#compile-time-options}{\texttt{ Compile-\/time options}}). Then, run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build -\/-\/target unittest}

\end{DoxyCode}
 The unit-\/test executable itself is located at {\ttfamily build/test/unit-\/test} \hypertarget{index_autotoc_md8}{}\doxysection{Benchmarking Intel HEXL}\label{index_autotoc_md8}
To run a set of benchmarks via Google benchmark, configure and build Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+BENCHMARK=ON} (see \href{\#compile-time-options}{\texttt{ Compile-\/time options}}). Then, run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build -\/-\/target bench}

\end{DoxyCode}
 The benchmark executable itself is located at {\ttfamily build/benchmark/bench\+\_\+hexl}\hypertarget{index_autotoc_md9}{}\doxysection{Using Intel HEXL}\label{index_autotoc_md9}
The {\ttfamily example} folder has an example of using Intel HEXL in a third-\/party project.\hypertarget{index_autotoc_md10}{}\doxysection{Debugging}\label{index_autotoc_md10}
For optimal performance, Intel HEXL does not perform input validation. In many cases the time required for the validation would be longer than the execution of the function itself. To debug Intel HEXL, configure and build Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+DEBUG=ON} (see \href{\#compile-time-options}{\texttt{ Compile-\/time options}}). This will generate a debug version of the library, e.\+g. {\ttfamily libhexl\+\_\+debug.\+a}, that can be used to debug the execution.

{\bfseries{Note}}, enabling {\ttfamily HEXL\+\_\+\+DEBUG=ON} will result in a significant runtime overhead. \hypertarget{index_autotoc_md11}{}\doxysection{Threading}\label{index_autotoc_md11}
Intel HEXL is single-\/threaded and thread-\/safe.\hypertarget{index_autotoc_md12}{}\doxysection{Documentation}\label{index_autotoc_md12}
See \href{https://intel.github.io/hexl}{\texttt{ https\+://intel.\+github.\+io/hexl}} for Doxygen documentation.

Intel HEXL supports documentation via Doxygen and sphinx. To build documentation, first install {\ttfamily doxygen} and {\ttfamily graphviz}, e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo apt-\/get install doxygen graphviz}

\end{DoxyCode}
 Then, configure Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+DOCS=ON} (see \href{\#compile-time-options}{\texttt{ Compile-\/time options}}). \hypertarget{index_autotoc_md13}{}\doxysubsection{Doxygen}\label{index_autotoc_md13}
To build Doxygen documentation, after configuring Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+DOCS=ON}, run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build -\/-\/target doxygen}

\end{DoxyCode}
 To view the generated Doxygen documentation, open the generated {\ttfamily build/docs/doxygen/html/index.\+html} file in a web browser.\hypertarget{index_autotoc_md14}{}\doxysubsection{Sphinx}\label{index_autotoc_md14}
To build the sphinx documentation, install {\ttfamily sphinx} and required dependencies {\ttfamily breathe, m2r2}, e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo apt-\/get install python3-\/sphinx}
\DoxyCodeLine{pip3 install breathe m2r2}

\end{DoxyCode}


Then, after configuring Intel HEXL with {\ttfamily -\/DHEXL\+\_\+\+DOCS=ON}, run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build -\/-\/target docs}

\end{DoxyCode}
 To view the generated Sphinx documentation, open the generated {\ttfamily build/docs/sphinx/html/index.\+html} file in a web browser.\hypertarget{index_autotoc_md15}{}\doxysection{Contributing}\label{index_autotoc_md15}
At this time, Intel HEXL does not accept external contributions. We encourage feedback and suggestions via issues.

For Intel developers, use \href{https://pre-commit.com/}{\texttt{ pre-\/commit}} to validate the formatting of the code.

Before contributing, please run 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake -\/-\/build build -\/-\/target check unittest}

\end{DoxyCode}
 and make sure pre-\/commit checks and all unit tests pass.\hypertarget{index_autotoc_md16}{}\doxysubsection{Repository layout}\label{index_autotoc_md16}
Public headers reside in the {\ttfamily hexl/include} folder. Private headers, e.\+g. those containing Intel(\+R) AVX-\/512 code should not be put in this folder.\hypertarget{index_autotoc_md17}{}\doxysubsection{Intel HEXL Publication}\label{index_autotoc_md17}
Find published paper at \href{https://arxiv.org/abs/2103.16400}{\texttt{ https\+://arxiv.\+org/abs/2103.\+16400}}.\hypertarget{index_autotoc_md18}{}\doxysubsection{Citing Intel HEXL}\label{index_autotoc_md18}
To cite Intel HEXL, please use the following Bib\+TeX entry.\hypertarget{index_autotoc_md19}{}\doxysubsubsection{Version 1.\+0}\label{index_autotoc_md19}

\begin{DoxyCode}{0}
\DoxyCodeLine{@misc\{IntelHEXL,}
\DoxyCodeLine{    title = \{\{I\}ntel \{HEXL\} (release 1.0)\},}
\DoxyCodeLine{    howpublished = \{\(\backslash\)url\{https://arxiv.org/abs/2103.16400\}\},}
\DoxyCodeLine{    month = mar,}
\DoxyCodeLine{    year = 2021,}
\DoxyCodeLine{    key = \{Intel HEXL\}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 