\hypertarget{namespaceintel_1_1hexl}{}\section{intel\+:\+:hexl Namespace Reference}
\label{namespaceintel_1_1hexl}\index{intel\+::hexl@{intel\+::hexl}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structintel_1_1hexl_1_1AllocatorBase}{Allocator\+Base}
\item 
struct \hyperlink{structintel_1_1hexl_1_1AllocatorInterface}{Allocator\+Interface}
\item 
class \hyperlink{classintel_1_1hexl_1_1NTT}{N\+TT}
\begin{DoxyCompactList}\small\item\em Performs negacyclic forward and inverse number-\/theoretic transform (\hyperlink{classintel_1_1hexl_1_1NTT}{N\+TT}), commonly used in R\+L\+WE cryptography. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} \{ \newline
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}{C\+M\+P\+I\+N\+T\+::\+EQ} = 0, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}{C\+M\+P\+I\+N\+T\+::\+LT} = 1, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}{C\+M\+P\+I\+N\+T\+::\+LE} = 2, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}{C\+M\+P\+I\+N\+T\+::\+F\+A\+L\+SE} = 3, 
\newline
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}{C\+M\+P\+I\+N\+T\+::\+NE} = 4, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}{C\+M\+P\+I\+N\+T\+::\+N\+LT} = 5, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}{C\+M\+P\+I\+N\+T\+::\+N\+LE} = 6, 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}{C\+M\+P\+I\+N\+T\+::\+T\+R\+UE} = 7
 \}\begin{DoxyCompactList}\small\item\em Represents binary operations between two boolean values. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}{Eltwise\+Add\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Adds two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}{Eltwise\+Add\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Adds a vector and scalar elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}{Eltwise\+Cmp\+Add} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t n, \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp, uint64\+\_\+t bound, uint64\+\_\+t diff)
\begin{DoxyCompactList}\small\item\em Computes element-\/wise conditional addition. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}{Eltwise\+Cmp\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t n, uint64\+\_\+t modulus, \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp, uint64\+\_\+t bound, uint64\+\_\+t diff)
\begin{DoxyCompactList}\small\item\em Computes element-\/wise conditional modular subtraction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}{Eltwise\+F\+M\+A\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$arg1, uint64\+\_\+t arg2, const uint64\+\_\+t $\ast$arg3, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Computes fused multiply-\/add ({\ttfamily arg1} $\ast$ {\ttfamily arg2} + {\ttfamily arg3}) mod {\ttfamily modulus} element-\/wise, broadcasting scalars to vectors. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}{Eltwise\+Mult\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Multiplies two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}{Eltwise\+Reduce\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand, uint64\+\_\+t n, uint64\+\_\+t modulus, uint64\+\_\+t input\+\_\+mod\+\_\+factor, uint64\+\_\+t output\+\_\+mod\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Performs elementwise modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}{Eltwise\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, const uint64\+\_\+t $\ast$operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Subtracts two vectors elementwise with modular reduction. \end{DoxyCompactList}\item 
void \hyperlink{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}{Eltwise\+Sub\+Mod} (uint64\+\_\+t $\ast$result, const uint64\+\_\+t $\ast$operand1, uint64\+\_\+t operand2, uint64\+\_\+t n, uint64\+\_\+t modulus)
\begin{DoxyCompactList}\small\item\em Subtracts a scalar from a vector elementwise with modular reduction. \end{DoxyCompactList}\item 
\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} \hyperlink{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}{Not} (\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} cmp)
\begin{DoxyCompactList}\small\item\em Returns the logical negation of a binary operation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}} 
\index{intel\+::hexl@{intel\+::hexl}!C\+M\+P\+I\+NT@{C\+M\+P\+I\+NT}}
\index{C\+M\+P\+I\+NT@{C\+M\+P\+I\+NT}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{C\+M\+P\+I\+NT}{CMPINT}}
{\footnotesize\ttfamily enum \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{intel\+::hexl\+::\+C\+M\+P\+I\+NT}\hspace{0.3cm}{\ttfamily [strong]}}



Represents binary operations between two boolean values. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{EQ@{EQ}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!EQ@{EQ}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a2dcbad7477fd40561e8b8198f173bd47}} 
EQ&Equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LT@{LT}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!LT@{LT}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac562607189d77eb9dfb707464c1e7b0b}} 
LT&Less than. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LE@{LE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!LE@{LE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006acfe6055d2e0503be378bb63449ec7ba6}} 
LE&Less than or equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{F\+A\+L\+SE@{F\+A\+L\+SE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!F\+A\+L\+SE@{F\+A\+L\+SE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006a946003f97ccc52d5d3b54ac0ec31bbfc}} 
F\+A\+L\+SE&False. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NE@{NE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!NE@{NE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006adc33066c3993e0d50896e533fd692ce0}} 
NE&Not equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{N\+LT@{N\+LT}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!N\+LT@{N\+LT}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ad7d6a13c7b311ec8a3c9fcfb1919a2f8}} 
N\+LT&Not less than. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{N\+LE@{N\+LE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!N\+LE@{N\+LE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006aacd748f300c5d189c47807e2a9d6ea57}} 
N\+LE&Not less than or equal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+R\+UE@{T\+R\+UE}!intel\+::hexl@{intel\+::hexl}}\index{intel\+::hexl@{intel\+::hexl}!T\+R\+UE@{T\+R\+UE}}}\mbox{\Hypertarget{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}\label{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006ac0d83f0b82a6b30de8811e69e6d95c61}} 
T\+R\+UE&True. \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}\label{namespaceintel_1_1hexl_a319244a133f57825ba7e593ad5c71709}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}}
\index{Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Add\+Mod()}{EltwiseAddMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Add\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Adds two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] + operand2[i]) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}\label{namespaceintel_1_1hexl_a8e0884463658eae11b6f1c6dfeb50b40}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}}
\index{Eltwise\+Add\+Mod@{Eltwise\+Add\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Add\+Mod()}{EltwiseAddMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Add\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Adds a vector and scalar elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to add. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Scalar to add. Must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] + operand2) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}\label{namespaceintel_1_1hexl_a5c4fd2ceb53b94efa5f5a959d7ee9819}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Cmp\+Add@{Eltwise\+Cmp\+Add}}
\index{Eltwise\+Cmp\+Add@{Eltwise\+Cmp\+Add}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Cmp\+Add()}{EltwiseCmpAdd()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Cmp\+Add (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{n,  }\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp,  }\item[{uint64\+\_\+t}]{bound,  }\item[{uint64\+\_\+t}]{diff }\end{DoxyParamCaption})}



Computes element-\/wise conditional addition. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to compare; stores result \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in {\ttfamily operand1} \\
\hline
\mbox{\tt in}  & {\em cmp} & Comparison operation \\
\hline
\mbox{\tt in}  & {\em bound} & Scalar to compare against \\
\hline
\mbox{\tt in}  & {\em diff} & Scalar to conditionally add\\
\hline
\end{DoxyParams}
Computes result\mbox{[}i\mbox{]} = cmp(operand1\mbox{[}i\mbox{]}, bound) ? operand1\mbox{[}i\mbox{]} + diff \+: operand1\mbox{[}i\mbox{]} for all $i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}\label{namespaceintel_1_1hexl_a78bf86d32140e39d8f99d474ccd0e226}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Cmp\+Sub\+Mod@{Eltwise\+Cmp\+Sub\+Mod}}
\index{Eltwise\+Cmp\+Sub\+Mod@{Eltwise\+Cmp\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Cmp\+Sub\+Mod()}{EltwiseCmpSubMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Cmp\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp,  }\item[{uint64\+\_\+t}]{bound,  }\item[{uint64\+\_\+t}]{diff }\end{DoxyParamCaption})}



Computes element-\/wise conditional modular subtraction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to compare \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in {\ttfamily operand1} \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus to reduce by \\
\hline
\mbox{\tt in}  & {\em cmp} & Comparison function \\
\hline
\mbox{\tt in}  & {\em bound} & Scalar to compare against \\
\hline
\mbox{\tt in}  & {\em diff} & Scalar to subtract by\\
\hline
\end{DoxyParams}
Computes {\ttfamily operand1}\mbox{[}i\mbox{]} = ({\ttfamily cmp}({\ttfamily operand1}, {\ttfamily bound})) ? ({\ttfamily operand1} -\/ {\ttfamily diff}) mod {\ttfamily modulus} \+: {\ttfamily operand1} for all i=0, ..., n-\/1 \mbox{\Hypertarget{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}\label{namespaceintel_1_1hexl_a5b65d563391b4a1a5041633aeb118aa5}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+F\+M\+A\+Mod@{Eltwise\+F\+M\+A\+Mod}}
\index{Eltwise\+F\+M\+A\+Mod@{Eltwise\+F\+M\+A\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+F\+M\+A\+Mod()}{EltwiseFMAMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+F\+M\+A\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{arg1,  }\item[{uint64\+\_\+t}]{arg2,  }\item[{const uint64\+\_\+t $\ast$}]{arg3,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Computes fused multiply-\/add ({\ttfamily arg1} $\ast$ {\ttfamily arg2} + {\ttfamily arg3}) mod {\ttfamily modulus} element-\/wise, broadcasting scalars to vectors. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em arg1} & Vector to multiply \\
\hline
\mbox{\tt in}  & {\em arg2} & Scalar to multiply \\
\hline
\mbox{\tt in}  & {\em arg3} & Vector to add. Will not add if {\ttfamily arg3} == nullptr \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $ [2, 2^{61} - 1]$ \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ modulus). Must be 1, 2, 4, or 8. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}\label{namespaceintel_1_1hexl_a705bc0321d937ae4d1f8d50279e3cff1}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Mult\+Mod@{Eltwise\+Mult\+Mod}}
\index{Eltwise\+Mult\+Mod@{Eltwise\+Mult\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Mult\+Mod()}{EltwiseMultMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Mult\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Multiplies two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em result} & Result of element-\/wise multiplication \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to multiply. Each element must be less than the modulus. \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to multiply. Each element must be less than the modulus. \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ p) Must be 1, 2 or 4.\\
\hline
\end{DoxyParams}
Computes {\ttfamily result}\mbox{[}i\mbox{]} = ({\ttfamily operand1}\mbox{[}i\mbox{]} $\ast$ {\ttfamily operand2}\mbox{[}i\mbox{]}) mod {\ttfamily modulus} for i=0, ..., {\ttfamily n} -\/ 1 \mbox{\Hypertarget{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}\label{namespaceintel_1_1hexl_af3ddae165283841d495a322275baf5ee}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Reduce\+Mod@{Eltwise\+Reduce\+Mod}}
\index{Eltwise\+Reduce\+Mod@{Eltwise\+Reduce\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Reduce\+Mod()}{EltwiseReduceMod()}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Reduce\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus,  }\item[{uint64\+\_\+t}]{input\+\_\+mod\+\_\+factor,  }\item[{uint64\+\_\+t}]{output\+\_\+mod\+\_\+factor }\end{DoxyParamCaption})}



Performs elementwise modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores the result \\
\hline
\mbox{\tt in}  & {\em operand} & \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in operand \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction \\
\hline
\mbox{\tt in}  & {\em input\+\_\+mod\+\_\+factor} & Assumes input elements are in \mbox{[}0, input\+\_\+mod\+\_\+factor $\ast$ p) Must be 0, 1, 2 or 4. input\+\_\+mod\+\_\+factor=0 means, no knowledge of input range. Barrett reduction will be used in this case. input\+\_\+mod\+\_\+factor $>$= output\+\_\+mod\+\_\+factor unless input\+\_\+mod\+\_\+factor == 0 \\
\hline
\mbox{\tt in}  & {\em output\+\_\+mod\+\_\+factor} & output elements will be in \mbox{[}0, output\+\_\+mod\+\_\+factor $\ast$ modulus) Must be 1 or 2. For input\+\_\+mod\+\_\+factor=0, output\+\_\+mod\+\_\+factor will be set to 1. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}\label{namespaceintel_1_1hexl_a6a45c30bc21b9b1e1410b23fce5424c8}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}}
\index{Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Sub\+Mod()}{EltwiseSubMod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{const uint64\+\_\+t $\ast$}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Subtracts two vectors elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to subtract from. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Vector of elements to subtract. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] - operand2[i]) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}\label{namespaceintel_1_1hexl_abc13b8f383d3af6471a5261ee2213b40}} 
\index{intel\+::hexl@{intel\+::hexl}!Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}}
\index{Eltwise\+Sub\+Mod@{Eltwise\+Sub\+Mod}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Eltwise\+Sub\+Mod()}{EltwiseSubMod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void intel\+::hexl\+::\+Eltwise\+Sub\+Mod (\begin{DoxyParamCaption}\item[{uint64\+\_\+t $\ast$}]{result,  }\item[{const uint64\+\_\+t $\ast$}]{operand1,  }\item[{uint64\+\_\+t}]{operand2,  }\item[{uint64\+\_\+t}]{n,  }\item[{uint64\+\_\+t}]{modulus }\end{DoxyParamCaption})}



Subtracts a scalar from a vector elementwise with modular reduction. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em result} & Stores result \\
\hline
\mbox{\tt in}  & {\em operand1} & Vector of elements to subtract from. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em operand2} & Elements to subtract. Each element must be less than the modulus \\
\hline
\mbox{\tt in}  & {\em n} & Number of elements in each vector \\
\hline
\mbox{\tt in}  & {\em modulus} & Modulus with which to perform modular reduction. Must be in the range $[2, 2^{63} - 1]$\\
\hline
\end{DoxyParams}
Computes $ operand1[i] = (operand1[i] - operand2) \mod modulus $ for $ i=0, ..., n-1$. \mbox{\Hypertarget{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}\label{namespaceintel_1_1hexl_a8c654502a5e7fe2cfdd198f0fd920f2a}} 
\index{intel\+::hexl@{intel\+::hexl}!Not@{Not}}
\index{Not@{Not}!intel\+::hexl@{intel\+::hexl}}
\subsubsection{\texorpdfstring{Not()}{Not()}}
{\footnotesize\ttfamily \hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT} intel\+::hexl\+::\+Not (\begin{DoxyParamCaption}\item[{\hyperlink{namespaceintel_1_1hexl_abdcc9d2d5bb10fa95d5f143874508006}{C\+M\+P\+I\+NT}}]{cmp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns the logical negation of a binary operation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cmp} & The binary operation to negate \\
\hline
\end{DoxyParams}
